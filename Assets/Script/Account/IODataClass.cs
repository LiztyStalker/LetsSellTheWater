//------------------------------------------------------------------------------
// <auto-generated>
//     이 코드는 도구를 사용하여 생성되었습니다.
//     런타임 버전:4.0.30319.36373
//
//     파일 내용을 변경하면 잘못된 동작이 발생할 수 있으며, 코드를 다시 생성하면
//     이러한 변경 내용이 손실됩니다.
// </auto-generated>
//------------------------------------------------------------------------------
using UnityEngine;
using System;
using System.Runtime.Serialization.Formatters.Binary;
using System.Runtime.Serialization;
using System.IO;
using System.Security.Cryptography;

public class IODataClass : SingletonClass<IODataClass>
{
	byte[] key = new byte[24];// = {1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4};// new byte[8];// {1, 1, 1, 1, 1, 1, 1, 1};

	const int myIterations = 1000;

	//암호화 알고리즘 랜덤 난수
	RNGCryptoServiceProvider rngCsp = new RNGCryptoServiceProvider();

	//암호 데이터
	byte[] salt = new byte[96];//{8, 7, 6, 5, 4, 3, 2, 1};//System.Text.Encoding.ASCII.GetBytes ("saltTestTextData");


	TripleDESCryptoServiceProvider tdes = new TripleDESCryptoServiceProvider (); // 키24개 필요
//	DESCryptoServiceProvider des = new DESCryptoServiceProvider(); // 키 8개 필요

	string m_filePath;

//	FileStream file;
//	CryptoStream cryptoStream;

	public IODataClass ()
	{
		//저장 및 불러오기
		m_filePath = Application.persistentDataPath;

		key = System.Text.Encoding.ASCII.GetBytes (SystemInfo.deviceUniqueIdentifier.Substring(0, 24));
		for (int i = 0; i < key.Length; i++) {key[i] = (byte)(Convert.ToByte(SystemInfo.deviceUniqueIdentifier[(int)key[i] % SystemInfo.deviceUniqueIdentifier.Length]) - 32);}
		rngCsp.GetBytes (salt);
		//Debug.Log("rngCsp : " + Convert.ToBase64String(salt));
	}


//	private byte[] getKey(){
////		SystemInfo.deviceUniqueIdentifier;
////		key[] = 
//
//	}

	/// <summary>
	/// 계정 해쉬 데이터 가져오기
	/// 없을 경우 딱 한번만 실행
	/// </summary>
	/// <returns>The account hash.</returns>
//	public string getAccountHash(string hash){
//
//		//초반 생성일 경우
//		if (hash == null) {
//
//		} 
//
//		return hash;
//	}

	/// <summary>
	/// 파일의 유무 판별
	/// </summary>
	/// <returns><c>true</c>, if file was ised, <c>false</c> otherwise.</returns>
	/// <param name="fileName">File name.</param>
	public bool isFile(string fileName){
		return File.Exists (string.Format("{0}/{1}.dat", m_filePath, fileName));
	}


	/// <summary>
	/// 암호화 하기 .dat
	/// </summary>
	/// <param name="filePath">File path.</param>
	/// <param name="fileName">File name.</param>
//	public CryptoStream encrypting(string filePath, string fileName){
//		return encrypting(filePath, fileName, "dat");
//	}
//
//	public CryptoStream encrypting(string filePath, string fileName, string fileExt){
//		using(file = new FileStream(string.Format("{0}/{1}.{2}", m_filePath, fileName, fileExt), FileMode.Create, FileAccess.Write)){
//			using(CryptoStream cryptoStream = new CryptoStream(file, tdes.CreateEncryptor(key, salt), CryptoStreamMode.Write)){
//				//					using(CryptoStream cryptoStream = new CryptoStream(file, des.CreateEncryptor(key, salt), CryptoStreamMode.Write))
//				return cryptoStream;
//			}
//		}
//		return null;
//	}


	/// <summary>
	/// 데이터 저장
	/// </summary>
	/// <returns><c>true</c>, if data was saved, <c>false</c> otherwise.</returns>
	/// <param name="account">Account.</param>
	public bool saveData(AccountSerialClass account, string fileName){
		try{
//			BinaryFormatter bf = new BinaryFormatter ();
//			using(FileStream file = File.Create (string.Format("{0}/{1}.dat", m_filePath, fileName))){
//				//계정 데이터 직렬화 파싱
//
//				//MemoryStream memory = new MemoryStream();
//
//				bf.Serialize (file, account);
//
//				//string encyptedData = AESEncrypting256(memory.ToString ());
//
//
//				Debug.Log("저장 완료 : " + account.GetType());
//				file.Close ();

//			using(MemoryStream memory = new MemoryStream()){

//				bf.Serialize (memory, account);
//				byte[] data = new byte[memory.Length];
//
////				memory.Write(data, 0, memory.Length);
//
//				memory.Read(data, 0, data.Length);
//
//				Debug.Log("memory : " + Convert.ToBase64String(data));
//
//				string encyptedData = DESEncrypting(memory.ToString ());
//				Debug.Log("encyptedData : " + encyptedData);



//			using(FileStream file = File.Create (string.Format("{0}/{1}.dat", m_filePath, fileName)))
//			cryptoStream = encrypting(m_filePath, fileName);
			using(FileStream file = new FileStream(string.Format("{0}/{1}.dat", m_filePath, fileName), FileMode.Create, FileAccess.Write)){
				using(CryptoStream cryptoStream = new CryptoStream(file, tdes.CreateEncryptor(key, salt), CryptoStreamMode.Write)){

					IFormatter bf = new BinaryFormatter ();

					bf.Serialize(cryptoStream, account);
					Debug.Log("저장 완료 : " + account.GetType());

					cryptoStream.Close();

					file.Close ();

					return true;
				}
			}
		}
		catch(Exception e){
			Debug.LogError("저장 오류 : " + e.Message);

			return false;
		}

	}

	/// <summary>
	/// 데이터 불러오기
	/// </summary>
	/// <returns><c>true</c>, if data was loaded, <c>false</c> otherwise.</returns>
	public AccountSerialClass loadData(string fileName){
		if (isFile(fileName)) {

			try{

				using(FileStream file = new FileStream(string.Format("{0}/{1}.dat", m_filePath, fileName), FileMode.Open, FileAccess.Read)){
					using(CryptoStream cryptoStream = new CryptoStream(file, tdes.CreateDecryptor(key, salt), CryptoStreamMode.Read)){

						IFormatter bf = new BinaryFormatter();

						AccountSerialClass accountData = (AccountSerialClass)bf.Deserialize(cryptoStream);
						Debug.Log("불러오기 완료 : " + accountData.GetType());

						cryptoStream.Close();
						file.Close();

						return accountData;
					}
				}
			}
			catch(Exception e){
				Debug.LogError("불러오기 오류 : " + e.Message);
				return null;
			}

//			IFormatter bf = new BinaryFormatter ();
//			using(FileStream file = File.Open (string.Format("{0}/{1}.dat", m_filePath, fileName), FileMode.Open)){
//
//				byte[] data = new byte[file.Length];
//
//				file.Read(data, 0, data.Length);
//				Debug.Log("file : " + data);
//
//				using(MemoryStream memoryStream = new MemoryStream()){
//
//					string originData = DESDecrypting(data.ToString());
//
//					Debug.Log("origin : " + originData);
//
//					memoryStream.Write(System.Text.Encoding.Unicode.GetBytes(originData), 0, originData.Length);
//
//					AccountSerialClass accountData = (AccountSerialClass)bf.Deserialize(memoryStream);
//					Debug.Log("저장 완료 : " + accountData.GetType());
//
//					return accountData;
//				}
//				file.Close ();


				//				if(serialClass is AccountSerialClass){
//					serialClass = (AccountSerialClass)bf.Deserialize(file);
//					Debug.Log("계정 : " + ((AccountSerialClass)serialClass).assets);
//				}
//
//				else if(serialClass is AnotherAccountSerialClass)
//					serialClass = (AnotherAccountSerialClass)bf.Deserialize(file);
//
//				else if(serialClass is CustomerAccountSerialClass)
//					serialClass = (CustomerAccountSerialClass)bf.Deserialize(file);
//
//				else if(serialClass is FinanceAccountSerialClass)
//					serialClass = (FinanceAccountSerialClass)bf.Deserialize(file);
//
//				else if(serialClass is ReputationAccountSerialClass)
//					serialClass = (ReputationAccountSerialClass)bf.Deserialize(file);
//
//				else if(serialClass is ResearchAccountSerialClass)
//					serialClass = (ResearchAccountSerialClass)bf.Deserialize(file);
//				else{
//					serialClass = null;
//				}
//
//				if(serialClass != null)
//					Debug.Log("불러오기 완료 : " + serialClass.GetType());

				
//				file.Close ();
//				return serialClass;
//			}


			return null;
		} else {
			Debug.Log("파일이 없습니다.");
			return null;
		}

	}

	private string DESEncrypting(string data){


		//salt = new byte[8];

//		using (rngCsp = new RNGCryptoServiceProvider()) {
//			rngCsp.GetBytes(salt);
//		}

//		int myIterations = 1000;

		try{
			Rfc2898DeriveBytes k1 = new Rfc2898DeriveBytes(key, salt, myIterations);
//			TripleDES encAlg = TripleDES.Create ();
//			encAlg.Key = k1.GetBytes(16);

			MemoryStream ms = new MemoryStream();

			StreamWriter sw = new StreamWriter(new CryptoStream(ms, new RijndaelManaged().CreateEncryptor(k1.GetBytes(32), k1.GetBytes(16)), CryptoStreamMode.Write));

//			byte[] utfd1 = new System.Text.UTF8Encoding(false).GetBytes(data);

			sw.Write(data);

			sw.Close();

			return Convert.ToBase64String(ms.ToArray());

//			k1.Reset();
		}
		catch(Exception e){
			Debug.LogError("암호화 오류 : " + e.Message);
		}

		return null;

//		RijndaelManaged rijndaelCipher = new RijndaelManaged ();
//
//		//입력받은 데이터를 바이트 배열로 변환
//		byte[] plainText = System.Text.Encoding.Unicode.GetBytes (data);
//
//		//딕셔너리 공격을 대비하여 키를 더 풀기 어렵게 만들기 위한 Salt 사용
//		byte[] salt = System.Text.Encoding.ASCII.GetBytes (key.Length.ToString ());
//
//
//		Rfc2898DeriveBytes secretKey = new Rfc2898DeriveBytes (key, salt);
//
//		//내부적인 오류로 인해 PasswordDeriveBytes는 권장하지 않음 - MS
////		PasswordDeriveBytes secretKey = new PasswordDeriveBytes (key, salt);
//
//
//
//		ICryptoTransform Encryptor = rijndaelCipher.CreateEncryptor(secretKey.GetBytes(32), secretKey.GetBytes(16));
//
//		MemoryStream memoryStream = new MemoryStream();
//
//		CryptoStream cryptoStream = new CryptoStream(memoryStream, Encryptor, CryptoStreamMode.Write);
//
//		cryptoStream.Write(plainText, 0, plainText.Length);
//
//		cryptoStream.FlushFinalBlock();
//
//		byte[] cipherBytes = memoryStream.ToArray();
//
//		memoryStream.Close();
//		cryptoStream.Close();
//
//		string EncrytedData = Convert.ToBase64String(cipherBytes);
//
//		return EncrytedData;
	}



	private string DESDecrypting(string data){

//		RijndaelManaged rijndaelCipher = new RijndaelManaged ();


		//salt = new byte[8];
		
//		using (rngCsp = new RNGCryptoServiceProvider()) {
//			rngCsp.GetBytes(salt);
//		}
		
//		int myIterations = 1000;
//		rngCsp.Dispose ();

		try{

			Rfc2898DeriveBytes k1 = new Rfc2898DeriveBytes(key, salt, myIterations);

//			TripleDES decAlg = TripleDES.Create ();
//			decAlg.Key = k1.GetBytes(16);
//			decAlg.IV = 

			ICryptoTransform cTransform = new RijndaelManaged().CreateDecryptor(k1.GetBytes(32), k1.GetBytes(16));

			byte[] bytes = Convert.FromBase64String(data);

			return new StreamReader(new CryptoStream(new MemoryStream(bytes), cTransform, CryptoStreamMode.Read)).ReadToEnd();

//			MemoryStream decryptionStreamBacking = new MemoryStream();
//			CryptoStream decrypt = new CryptoStream(decryptionStreamBacking, decAlg.CreateDecryptor(), CryptoStreamMode.Write);
//
//			byte[] data1 = System.Text.Encoding.ASCII.GetBytes(data);
//
//			decrypt.Write(data1, 0, data1.Length);
//
//			decrypt.Flush();
//
//			decrypt.Close ();
//
//			string data2 = new System.Text.UTF8Encoding(false).GetString(decryptionStreamBacking.ToArray());
//
//			return data2;
//

		}
		catch(Exception e){
			Debug.LogError("복호화 오류 : " + e.Message);
		}
		return null;


//		RijndaelManaged rijndaelCipher = new RijndaelManaged ();
//
//		byte[] EncryptedData = Convert.FromBase64String (data);
//		byte[] salt = System.Text.Encoding.ASCII.GetBytes (key.Length.ToString ());
//
//		Rfc2898DeriveBytes secretKey = new Rfc2898DeriveBytes (key, salt);
//
//		ICryptoTransform Decryptor = rijndaelCipher.CreateDecryptor(secretKey.GetBytes(32), secretKey.GetBytes(16));
//
//		MemoryStream memoryStream = new MemoryStream (EncryptedData);
//
//		CryptoStream cryptoStream = new CryptoStream (memoryStream, Decryptor, CryptoStreamMode.Read);
//
//		byte[] plainText = new byte[EncryptedData.Length];
//
//		int DecryptedCount = cryptoStream.Read (plainText, 0, plainText.Length);
//
//		memoryStream.Close ();
//		cryptoStream.Close ();
//
//		string DecryptedData = System.Text.Encoding.Unicode.GetString (plainText, 0, DecryptedCount);
//
//		return DecryptedData;
	}

}


