//------------------------------------------------------------------------------
// <auto-generated>
//     이 코드는 도구를 사용하여 생성되었습니다.
//     런타임 버전:4.0.30319.34209
//
//     파일 내용을 변경하면 잘못된 동작이 발생할 수 있으며, 코드를 다시 생성하면
//     이러한 변경 내용이 손실됩니다.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.Linq;

public class EmployeePackageClass : SingletonClass<EmployeePackageClass>
{

	const char c_lineChar = '\n';
	const char c_splitChar = '\t';
	const int c_constraintCount = 50; //일정횟수 루프

	Sprite m_emptyEmployee;
	List<EmployeeClass> m_employeeList = new List<EmployeeClass> ();
	List<EmployeeClass> m_nowEmployeeList = new List<EmployeeClass>();

	TextAsset m_textAsset;

	public EmployeePackageClass ()
	{
		//initParsing ();
	}

	public bool assetBundleInitParsing(TextAsset textAsset){
			
		m_textAsset = textAsset;
		if (m_textAsset != null) {
			initParsing ();
			return true;
		} else {
			throw new MissingReferenceException("TextAsset 없음 : " + textAsset);
			return false;
		}
			
	}

	private void initParsing(){
		
//		Sprite[] sprites = Resources.LoadAll<Sprite> ("Image/Employee");
		
//		TextAsset textAsset = (TextAsset)Resources.Load ("Data/Employee/Employee", typeof(TextAsset));
		string[] splitList = m_textAsset.text.Split (c_lineChar);


		//모든 데이터 구조체에 삽입
		for (int i = 0; i < splitList.Length; i++) {
			
			if(splitList[i] == "")
				continue;

			Debug.Log("data : " + splitList[i]);

			string[] subSplit = splitList[i].Split(c_splitChar);
			
//			Sprite selectSprite = sprites.Where(sprite => sprite.name.Equals(subSplit[0])).Select(sprite => sprite).SingleOrDefault();


			//해당하는 키에 맞는 틀 스프라이트 리스트 가져오기
			Sprite[] sprites = Resources.LoadAll<Sprite> ("Image/Employee/" + subSplit[0]);

			if(sprites != null){




				string key = subSplit[0];
//				string imageKey = subSplit[1];
				string name = subSplit[1];
				bool gender = (subSplit[2] == "0") ? false : true;
				TYPE_CHARACTER characterType = (TYPE_CHARACTER)int.Parse(subSplit[3]);
				TYPE_RANK rank = (TYPE_RANK)int.Parse(subSplit[0].Substring(3, 1));
				int health = int.Parse(subSplit[4]);
				int quickness = int.Parse(subSplit[5]);
				int intelligence = int.Parse(subSplit[6]);
				int charm = int.Parse(subSplit[7]);
				int salary = int.Parse(subSplit[8]);
				int workmanship = int.Parse(subSplit[9]);
				int experiance = 0;
				int experianceMax = int.Parse(subSplit[10]);
				//	int m_abilityPoint;
				int employmentFee = int.Parse(subSplit[11]);
				string contents = subSplit[12];

				m_employeeList.Add(new EmployeeClass(
												 sprites, 
												 key, 
			                                     name,
			                                     gender,
			                                     characterType,
												 rank,
			                                     health,
												 quickness,
												 intelligence,
			                                     charm,
			                                     salary,
			                                     workmanship,
			                                     experiance,
			                                     experianceMax,
			                                     employmentFee,
												 contents
			                                     ));

				Debug.Log ("Employee name : " + name);
			}
			else{
				Debug.Log("데이터 없음 : " + subSplit[0]);
			}
		}
	}






	/// <summary>
	/// 직원 리스트 가져오기
	/// </summary>
	/// <returns>The employee list.</returns>
	/// <param name="isRefresh">If set to <c>true</c> is refresh.</param>
	public List<EmployeeClass> getEmployeeList(bool isRefresh = false){

//		List<EmployeeClass> m_nowEmployeeList = new List<EmployeeClass> ();


		//5분 타이머가 지나갔을 경우 새로고침
		//if (m_timer <= 0f) {
		//새로고침
		if (isRefresh) {

			//직원 필터링
			//현재 지니고 있는 직원 리스트 가져오기
			//현재 연구된 데이터를 가지고 필터링하기 - 직원 숙련 확률
			//개수만큼 반복
			//비숙련자 ~ 엘리트 랜덤 선택 - 현재 지니고 있는 직원이 같으면 재반복
			//

			m_nowEmployeeList.Clear ();

			//구인 비율
			int[] ratio = AccountClass.GetInstance.researchAccount.employeeRatio ();

//			foreach(int ratioI in ratio){
//				Debug.Log("ratioCnt : " + ratioI);
//			}
			//구인창 길이
			int length = AccountClass.GetInstance.researchAccount.employeeLength ();
			for (int i = 0; i < length; i++) {
				//엘리트 숙련전문 전문 숙련 비숙련

				//해당하는 직원의 숙련직원 리스트 가져오기
				int index = ratio.Length - 1;
				while (index >= 0) {
					int check = UnityEngine.Random.Range (0, 101);
					Debug.Log("check : " + check + " " + ratio [index]);
					if (check < ratio [index]) {
						break;
					}
					index--;
				}

				EmployeeClass[] employees = getEmployeeGrade (index + 1);

				Debug.Log ("employees : " + employees.Length);
//				int index = Random.Range (0, m_employeeList.Count);
				//비숙련자 숙련자 확률 계산
				//숙련도의 확률에 따라 인덱스 랜덤으로 가져오기
				//랜덤으로 직원 가져오기
				//현재 직원이 없으면 직원 리스트에 삽입
				//만약 일정 횟수 이상 중복이 된다면 삽입하지 말기
				if (employees.Length != 0) {
					int constraintCount = c_constraintCount;
					while (constraintCount != 0) {
						int rand = UnityEngine.Random.Range (0, employees.Length);
						Debug.Log ("rand : " + rand);
						EmployeeClass emp = employees [rand];
						if (!m_nowEmployeeList.Contains (emp)) {
							if (!AccountClass.GetInstance.isEmployee (emp.key)) {
								m_nowEmployeeList.Add (emp);
								break;
							}
						}

						//일정 횟수 이상 중복시 그냥 나가기
						//성능 저하의 요인이 될 수 있음
						constraintCount--;
					}
				}
			}
		} 
		else {

			List<EmployeeClass> m_filterEmployeeList = new List<EmployeeClass> ();
			//구인시 이미 구인한 데이터는 보여주지 말아야 함
			if (m_nowEmployeeList.Count > 0) {
				foreach (EmployeeClass emp in m_nowEmployeeList) {
					if (!AccountClass.GetInstance.isEmployee (emp.key)) {
						m_filterEmployeeList.Add (emp);
					}
				}
			}
			m_nowEmployeeList.Clear ();
			m_nowEmployeeList.AddRange (m_filterEmployeeList.AsEnumerable<EmployeeClass> ());
		}
		return m_nowEmployeeList;
	}

	/// <summary>
	/// 직원 가져오기 - 새 데이터
	/// </summary>
	/// <returns>The employee.</returns>
	/// <param name="employee">Employee.</param>
	public EmployeeClass getEmployee(EmployeeClass employee){
		if(m_employeeList.Contains(employee)){
			//데이터 복사
			return new EmployeeClass(employee);
		}
		
		Debug.Log ("데이터를 찾지 못했습니다. " + employee.name);
		return null;
	}

	/// <summary>
	/// 직원 찾기
	/// </summary>
	/// <returns>The employee.</returns>
	/// <param name="key">Key.</param>
	public EmployeeClass getEmployee(string key){
		return new EmployeeClass(m_employeeList.Where (employee => employee.key == key).Select (employee => employee).SingleOrDefault ());
	}

	/// <summary>
	/// 직원 저장 데이터를 가지고 직원 가져오기
	/// </summary>
	/// <returns>The employee.</returns>
	/// <param name="employeeSerial">Employee serial.</param>
	public EmployeeClass getEmployee(EmployeeSerialClass employeeSerial){
		EmployeeClass employ = getEmployee (employeeSerial.key);
		if (employ != null) {
			employ.setEmployeeSerial(employeeSerial);
		}
		return employ;
	}

	/// <summary>
	/// 직원 빈 스프라이트 가져오기
	/// </summary>
	/// <returns>The empty employee sprite.</returns>
	public Sprite getEmptyEmployeeSprite(){
		return m_emptyEmployee;
	}

	private EmployeeClass[] getEmployeeGrade(int index){
		string data = string.Format ("EP{0:d2}", index);
		Debug.Log ("data : " + data + m_employeeList.Count);
		return m_employeeList.Where (employee => employee.key.Contains(data)).ToArray<EmployeeClass>();
	}



	//사용하지 않음
	//텍스쳐 병합
	//	private void textureMarge(){

	//	string[][] imageKey = new string[][]{new string[]{"Head_M", "Face_M", "Body_M", "Arm_M", "Leg_M"}, 
	//										new string[]{"Head_F", "Face_F", "Body_F", "Arm_F", "Leg_F"}};
	//	Dictionary<int, List<Sprite[]>> m_employeeIcons = new Dictionary<int, List<Sprite[]>>();

	//			Sprite[] sprites = new Sprite[7];
	//


	
	//		for (int i = 0; i < imageKey.Length; i++) {
	//			List<Sprite[]> spriteList = new List<Sprite[]>();
	//			for(int j = 0; j < imageKey[i].Length; j++){
	//
	//				Sprite[] spriteArray = Resources.LoadAll<Sprite>("Image/Employee/" + imageKey[i][j]);
	//
	//				if(spriteArray != null){
	//					spriteList.Add(spriteArray);
	//					Debug.Log("이미지 키 : " + imageKey[i][j]);
	//				}
	//			}
	//			m_employeeIcons.Add(i, new List<Sprite[]>(spriteList));
	//		}
	
	
	//Head_F Face_F Body_F Arm_F Leg_F
	//Head_M Face_M Body_M Arm_M Leg_M


	//			List<Sprite[]> spritePack =  m_employeeIcons[int.Parse(subSplit[3])];
	//
	//			Debug.Log("spritePack : " + spritePack.Count);
	//
	//			if(spritePack.Count > 0){
	//				int offset = 0;
	//				for(int j = 0; j < spritePack.Count; j++){
	//
	//					Debug.Log("j : " + j);
	//
	//					if(spritePack[j].Length > 0){
	//						int index = int.Parse(subSplit[1].Substring(2 + (j * 2), 2)) * ((j == 4) ? 2 : 1);
	//						Sprite sprittmp = spritePack[j][index];
	//
	//						if(sprittmp != null){
	//							sprites[j + 1 + offset] = sprittmp;
	//							if(j == 4){
	//								sprites[j + 2] = spritePack[j][index + 1];
	//								offset = 1;
	//							}
	//						}
	//						else{ 
	//							sprites = null;
	//							break;
	//						}
	//
	//
	//
	//					}
	//					else{
	//						sprites = null;
	//						break;
	//					}
	//				}
	//			}
	//			else{
	//				sprites = null;
	//			}
	//사용 불가
	//Advance만 사용 가능
	//				Texture2D texture1 = sprites[1].texture;
	//				Texture2D texture2 = sprites[2].texture;
	//
	//				Color[] bData = texture1.GetPixels();
	//				Color[] fData = texture2.GetPixels();
	//				
	//				for(int y = 0; y < 64; y++){
	//					for(int x = 0; x < 64; x++){
	//						bData[x + (y * 64)] = fData[x + (y * 64)];
	//					}
	//				}
	//				
	//				Texture2D final = new Texture2D(64, 64);
	//				final.SetPixels(bData);
	//				final.Apply();
	//				
	//				sprites[0] = Sprite.Create(final, new Rect(0f, 0f, 64f, 64f), new Vector2(0.5f, 0.5f));
	//	}
}


